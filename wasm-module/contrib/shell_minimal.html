<!doctype html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Wallycore shell</title>
  <style>
    textarea {
      font-family: monospace;
      width: 80%;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
  </style>
</head>

<body>
  <textarea id="output" rows="8"></textarea>
  {{{ SCRIPT }}}
  <script async type='text/javascript' src='main.js'></script>
  <script defer type='text/javascript'>
    function main() {
      if (init() !== 0) {
        alert("initialization failed");
        return;
      };
      console.log("Libwally successfully initialized\n");
      var wallet = newWallet();
      if (wallet === "") {
        alert("Wallet creation failed");
        return;
      }

      otherMnemonic = "bag buffalo scrap bamboo crane release history bullet screen junior type camp creek flip boy cabbage opera dizzy layer army useless domain fall mirror";
      restored = JSON.parse(restoreWallet(otherMnemonic));
      if (restored.xpub.localeCompare("xpub661MyMwAqRbcGqusUEqrpdR5YiQHQnaBbyrW2pWNJAUrQK6ZNDwrMyUFNsmR3WtzGgUwwHAX5P8ymmQDgLDKHcWThLVunQXWmvskKEoKp5U") === 0) {
        console.log("restored wallet is OK ");
      }

      // console.log("first derived pubkey is " + restored.pubkey0);

      // try to create a confidential address out of a script
      // var script = "5121036f611d04b32a28d8765350f94b9ee519b5607c35a293363148713a971809cf9b21036275723cc7f370ebde1c573bf68900f01a204a4709473d6ae3e110095b081e9b2103f638f867c78a083ef12efc8ee14d856e0bc0fdb094306f6e5744d865f193f93653ae64022c01b269685321032bd879a5803895e510b5159a0b13305c647036466f822db5c57e6efc41750a98210244d49967c7c2d0f002f5769e9eb8b1b6c06e094d9022ae8162596a2bc06b6c4c210299697af95482056fa7d56125ea1edc1c68c0eee7d5d847f13dd2344d79150e5453af5221035d2bfec06d1ffe2854fe2ef8cd9758ab58ddf7ee939efb3d6abb9634d541b62b21027782205e53634b893e4fe763060b92c27090609f77b7420329acfd8b4eca13c621020e0eee8a886c4d619e34d4b828406ecd37aa803bdc03b95e44335ecf3fd9bf2d53af532102ac400f4ed0b8f821af77ba4f6a115eeb6871226e94df6095610cda7daab5cdee2102e73e89a7bfbeb60aea35a21f499aae9a6570b1687d8e43bf016d3c379a20e5b72102c1448f93b8391c2e550690c5ae2a373435e3e42a13204bc2cdd51fa378209b2753af5221022e92129208f3ce38ffde337e63060ebdd8627d5a621f593620ab8d2c878ba4032102f6e9c339b9ece67a171329aa2c361e3d25e50a4ad4175fc8c7b259d131ff82d92103a11f6f6d9a73ed187009f92cac185daef62bedd995dc3f84e04c369aa6f783af53af53210230db9e97fd444bbde0b5b4607903553ae294dc2909c2dd972738519c0783dbeb2102fdff72bff95447786e64427b8948215e97915ba58004edc3d4806989418395a8210218a3eba6da1e00ab11d92a502d96fae41971c962bd06c49e8f63e309748e400a53af5121023c88c1920452850482955eabe3342eb1699e4bf095427ac68614c9ca620d6bdc210338585bd8711650d5479e4142dbac328627b02321edd2fcb0e289f88a3142a2372102a06c1c020dbff7515c7dfeda755a29840235c6e6339e8214d12093ea471f87f253ae64022c01b2696853210347e8e70b54af0f329050426cdffbac4f2ca518f023e692ef8a3acdac443309ad21037e1463261f116ea7378144c8ad25af0b1211532d6fa32712378bf16f2b44c5a121035f81c2880ea04ce75e3ba50492b7b1a41cf32e0797a5615249e3d16cf26f63e253af522103b16a14753140dfd863a887f7748f518570d0787164c15debd9f07842d72790012102c11de8d77df28c24c2751cf56acd989dc87858555e82912d02a2352a88740b5c2103567a6649e85b1ec66fb4155b305244533c06b1fe1e7309d4908a1111414435bc53af5321030c997fa17f018e85e04db0ea2690da5c09a295da3e4c4522b366a3d7113e50e92102c6fa89cfe2b2eac1cc303c0de2dabc6b89ad290fdf72ffc4eef51b1c4ae24bb7210397c22c5634e5dae8a273b5ed93327a150a159a7058b6b72deb8871218f63299f53af51210238a257943c66e36a867ed337e9523f82131e550809a2835ea4ed7ce9ef04668b2102b83ebc4982f523b840e557b1b1c3c13589b6e0b3262e138e1bf0212727b0160b210346523c185ede552e52865408003ced2718f332ed8af65fef8b82b45225a2bf4a53ae64022c01b2696851210228b1422c02b60152602eecbacff7eb32a5e642cef30213e99b8acf3b1b7501d421024f38f9acae6f24bf7f95a1e2e663d804bcd9a7f0bc3414f9107966af801c193321037bac05d72379a23a0f6a95fdbf22b069fe2965ee4c5ecdb37f1aa85cfc1266f153ae64022c01b26968532102b1e413bb57ba7699f065428b9769a2f8fd55522094b6e0ae8e9331f0c23f006621022d7fc47891dbb1b76417db40d084ede76e405f7dec21f7615bf3f6a2ad2d82dc2102c308de0c84f1cdd8ed5e6eb4e36968c1fa9a5b1d912c55b945f10524cf83a3ec53af5221026edfbdc92ab2b8c51c192a226a2ebb59085a36ea19ebac09b38dc5634ccee8012102257ec1cefe4ff5a45c98afd4a14e623538e8bf7676ab01ab760d39b2079bfb2f210243be3c9597e2607b289d04a269e8aaaec8ef74a698f1937bcbf961acb88e3ed453af532102289c3d92bb5788269c8f4748fe9cb987864855d5bf32de37c728e3f743af7dd921038776c2a17e6c3096493b5ab1df1ebced17acdb5200004bad34c622a4f9fe7c522102324a31538849cf909d2c37475aad61eed7abdecab374fa159d153688f304ea4953ae";

      // get a private key to import in elements to create our first UTXO
      var path = "42/0";
      firstAddress = JSON.parse(newAddressFromXprv(restored.xprv, path, 0));
      console.log("address is " + firstAddress.unconfidentialAddress);
      console.log("pubkey is " + firstAddress.pubkey)
      // derive an address from the xpub
      var path = "0/0";
      mineAddress = JSON.parse(newAddressFromXprv(restored.xprv, path, 0));
      // console.log("address is " + mineAddress.unconfidentialAddress);
      console.log("pubkey is " + mineAddress.pubkey)

      var path = "c8c0091a55738d9594cedc26f7f07832753ef0ceb1d4ec8092d101c90fb92e06";
      theirAddress = JSON.parse(newAddressFromXpub(restored.xpub, path, 2));
      // console.log("address is " + theirAddress.unconfidentialAddress);
      console.log("pubkey is " + theirAddress.pubkey)

      var path = "2/0";
      multisigAddress1 = JSON.parse(newAddressFromXpub(restored.xpub, path, 0));
      // console.log("address is " + theirAddress.unconfidentialAddress);
      console.log("pubkey is " + multisigAddress1.pubkey)

      var path = "3/0";
      multisigAddress2 = JSON.parse(newAddressFromXpub(restored.xpub, path, 0));
      // console.log("address is " + theirAddress.unconfidentialAddress);
      console.log("pubkey is " + multisigAddress2.pubkey)

      var script = "5221" + multisigAddress1.pubkey + "21" + multisigAddress2.pubkey + "52ae";
      console.log("multisig script is " + script);
      multisig = getWitnessAddressFromScript(script);
      console.log("multisig address is " + multisig);

      // create a new tx that spend prevTx
      var unblindedPrevTx = "0200000001014951b077c48f28a4321bc283a77c2ee5dd50ebfd9457330c34dc3c4fcae8b00f0100000000ffffffff0301230f4f5d4b7c6fa845806ee4f67713459e1b69e8e60fcee2e4940c7a0d5de1b20100000000000003e80016001455450f596ae6065960ed733a34473f21e0acf85001230f4f5d4b7c6fa845806ee4f67713459e1b69e8e60fcee2e4940c7a0d5de1b20100000000127a3396001600142453edffa30a4dc4e45783d5fb2e065475bcba4f01230f4f5d4b7c6fa845806ee4f67713459e1b69e8e60fcee2e4940c7a0d5de1b201000000000000020200000000000000000247304402205f3af25620dc5202020d779946df0d42415b41a4a222993f85194bfff2e0bb4402204a738877d00eea66d3f8b0c5cbc1a09e92cf8b4d4504121344dacb84aace050d0121023a0665776a8cb54b5b2ad524ea8c322a3681ad200ec634ac28565b02ab16adbf00000000000000";

      let vout = 1;
      let amountSpent = 0;
      let getInfoFromPrevTx = new Promise((resolve, reject)=> {
        var inputs = [];
        inputs[0] = extractOutputFromPrevTx(unblindedPrevTx, vout);
        resolve(inputs);
      })
      getInfoFromPrevTx
        .then(inputs=> {
        inputs.forEach((value)=> {
          amountSpent += value.amount;
        })

        let rewardAmt = 10000;
        let targetAmt = 10000;
        let changeAmt = amountSpent - rewardAmt - targetAmt;

        let change = {
          "address": multisig,
          "amount": changeAmt,
          "asset": inputs[0].asset
        }
        let reward = {
          "address": theirAddress.unconfidentialAddress,
          "amount": rewardAmt,
          "asset": inputs[0].asset
        }
        let target = {
          "address": mineAddress.unconfidentialAddress,
          "amount": targetAmt,
          "asset": inputs[0].asset
        }
        var outputs = [target, reward, change];
        console.log(outputs);

        newTx0 = createNewTx(inputs, outputs);
        console.log("First Tx is " + newTx0);

        let address = "ert1q24zs7kt2ucr9jc8dwvarg3ely8s2e7zsz3gkvs"; // address found in the UTXO we're spending
        return signedTx0 = signSingleSigTx(newTx0, address, restored.xprv, "42/0", 0);
        })
        .then(signedTx0=> {
          console.log("signedTx0 " + signedTx0);
          vout = 2;
          var inputs = [];
          inputs[0] = extractOutputFromPrevTx(signedTx0, vout);

          return inputs;
        })
        .then(inputs=> {
          console.log(inputs);
          inputs.forEach((value)=> {
            amountSpent += value.amount;
          })

          targetAmt = amountSpent;

          target = {
            "address": mineAddress.unconfidentialAddress,
            "amount": targetAmt,
            "asset": inputs[0].asset
          }
          outputs = [target];

          newTx1 = createNewTx(inputs, outputs);
          console.log("First Tx is " + newTx1);

          // sign the multisig input
          signature1 = signMultisigTx(newTx1, multisigAddress1.pubkey, script, restored.xprv, "2/0", 0);
          console.log("signature1 is " + signature1);
          signature2 = signMultisigTx(newTx1, multisigAddress2.pubkey, script, restored.xprv, "3/0", 0);
          console.log("signature2 is " + signature2);

          signatures = signature1 + ' ' + signature2;

          // put the signature together to create a fully signed transaction
          signedMultiTx = combineSignaturesInTx(newTx1, signatures, script);
          console.log("signed multisig tx is " + signedMultiTx);

        })

      // newTx = createIssueAssetTx(unblindedPrevTx, contract_hash, multisig, mineAddress.unconfidentialAddress);


      // sign the tx
      /*  we need to pass:
      **  - the unsigned transaction
      **  - the address from the previous tx we're spending, so that we know which privkey we're looking for
      **  - the derivation path, which is not necessarily the exact path, we'll look up to 100 pubkeys from the given path
      **  - the encrypted wallet and password to retrieve the master private key 
      * */
      // let address = "ert1qmz4vuj0y7vc36rm630d9yfx27ppkg06smtljyq";

      // create another tx that spend the multisig


      // sign an arbitrary hash with a key derived from our xprv
/*       stringToEncrypt = "It is notable that the response to each public tragedy or threat in modern America seems to involve a call for citizens to surrender more of their rights.";
      signature = signHash(restored.xprv, "0/0", 0, stringToEncrypt);

      console.log(signature);

      signatureOK = verifySignature(JSON.parse(signature).address, stringToEncrypt, JSON.parse(signature).signature);
      console.log(signatureOK);

      let numberToEncrypt = 3;
      let Wallets = [];
      for (i = 0; i < numberToEncrypt; i++) {
        var temp = JSON.parse(newWallet());
        
        var wallet = {
          "xprv": temp.xprv,
          "xpub": temp.xpub,
          "hdPath": "100/1000", 
        }

        Wallets.push(wallet);
      }

      let Ciphers = [];
      for (i = 0; i < numberToEncrypt; i++) {
        cipher = JSON.parse(encryptMessageWithXpub(stringToEncrypt, Wallets[i].xprv, Wallets[i].hdPath, 100));

        Ciphers.push(cipher);
      }

      console.log("Ciphers is " + JSON.stringify(Ciphers));

      // try to decrypt the messages
      for (i = 0; i < Ciphers.length; i++) {
        temp = Ciphers[i];

        var path = temp.hdPath;
        var range = temp.range;
        var encryptedMessage = temp.encryptedMessage;
        var pubkey = temp.pubkey;
        var senderPubkey = temp.senderPubkey;
        var xprv = Wallets[i].xprv;

        var clearMessage = decryptMessage(encryptedMessage, xprv, path, range, pubkey, senderPubkey);
        console.log("clear message is " + clearMessage);
      }*/

      // cleanup when we're over
      cleanUp();
      console.log("Cleanup and terminating");
    }
    var Module = {
      onRuntimeInitialized: function () {
        main();
      }
    };
  </script>
</body>

</html>