# contribox-client-multisign
Web RPC protocol for multisign with Elements transations

## Contribox web plugin

### Architecture

This plugin is composed of 3 parts:
1. Libwally
2. Minsc
3. A middle layer that will expose functional API and calls the low-level libraries

### Libwally

[Libwally](https://github.com/ElementsProject/libwally-core) is a cross-platform library of bitcoin and elements wallet primitives.

It is written in C, and can be compiled with Python or Java wrapper.

See the [API](https://wally.readthedocs.io/) documentation for more information. 

### Minsc 

### Middle layer

## API call

## new_wallet

### Inputs

1. string `entropy`: 32 or 64B of entropy provided by the system. 

### Outputs

1. string `xpub`: a base 58 encoded version of the extended public key that can be used by other users to compute new addresses on behald of others.
2. string `xprv`: a hex encoded version of the AES encrypted extended private key. It must be stored in the permanent storage of the browser, and only the user should be able to decrypt it.
3. string `master_blinding_key`: a hex encoded version of the AES encrypted master blinding key, which allow to blind and unblind all the user's output. It must be stored in the browser permanent storage. For security reason, maybe we should share a clear version with trusted entities to prevent user being unable to unblind his own outputs if he loses this.
4. (optional) string `mnemonic`: a 12 or 24 words phrase that can be written down and used as an optional backup system to restore lost `xprv` and `master_blinding_key`

### Description

`new_wallet` is the first API call that must be made, since it generates all the cryptographic material we need for the subsequent steps.

It takes the given entropy and uses it to generate a seed (a `mnemonic` is basically a human-readable version of this), and from this seed an extended private key. 

From this key it is possible to derivate a virtually unlimited number of new key pairs. 

`xprv` is the most critical piece of information here, as anyone that get a hold of it can impersonate the user in any transaction, not only past, but also to come.

`xpub` is relatively less critical, having it would allow an attacker to derive all the pubkeys (hence the address) of the user. This could be a privacy issue, but since we blind everything and use a lot of multisig (which hides the participants pubkey as long as it is not spent), I don't think this is a concern here, that's why this is not returned encrypted. 

`master_blinding_key` should be protected, as compromising it wouldn't be as bad as the `xprv`, but would allow the attacker to unblind all the users' output.

## new_address

### Inputs

1. string `xpub`: an extended public key (see `new_wallet`). Can be the user's, or someone else's.
2. string `hd_path`: must only contains numeric characters and `/` to separate them. List of indexes used for key derivation. 

### Outputs

1. string `address`: a base 58 bech32 address commiting to `pubkey`.
2. string `pubkey`: the public key found at `hd_path` for the given `xpub`.

## new_confidential_address

### Inputs

1. string `address`: an address generated by `new_address`
2. string `master_blinding_key`: return by `new_wallet`. 

### Outputs

1. string `confidential_address`: the base 58 encoded confidential address for the given `address` and `master_blinding_key`.
2. string `blinding_privkey`: the private key generated (32B) in hex format. Anyone having this information is also able to unblind all the outputs using this address.

## new_multisig_address

### Inputs

1. int `threshold`: the minimum number of signatures required out of the total number of pubkeys to produce a valid transaction.
2. string `pubkeys`: all the pubkeys used in the multisig, space separated.
3. string `hd_paths`: all the derivation paths, space separated, there must be as many paths than pubeys.

### Outputs

1. string `redeem_script`: a hex encoded byte string of the resulting bitcoin script.
2. string `address`: a bech32 address commiting to the `redeem_script`.

**Note**: those multisig adresses are unblinded, and must be blinded with `new_confidential_address`. But since the address is shared amongst _n_ participants, they all need the blinding keys. Any user in the multisig could use his own master blinding key to create a confidential transaction, but should then share the key with all the other participants.

## create_tx

### Inputs

1. string `prev_tx`: hex encoded transaction containing the UTXO we're spending.
2. string `asset`: hex encoded asset ID of the asset provided on enrollment.
3. string `address_1`: address of the first output.
4. (optional)string `address_2`: address for the second output. 
5. (optional)string `contract_hash`: an optional 32B piece of information (usually, a hash) that can be committed inside the asset issuance.

### Outputs

1. string `tx`: hex encoded new transaction that spends `prev_tx`

## sign_tx

### Inputs

1. string `tx`: hex encoded transaction to sign
2. string `hd_path`: must only contains numeric characters and `/` to separate them. List of indexes used for key derivation. 
3. string `value`: amount of the UTXO we're speding. If the previous transaction was blinded, it is the field `valuecommitment` in the output of `decoderawtransaction` elements rpc call. If it's not, pass the clear amount (e.g. "1.00012").

### Outputs

1. string `signed_tx`: hex encoded signed transaction
