# contribox-client-multisign
Web RPC protocol for multisign with Elements transations

## Contribox web plugin

### Architecture

This plugin is composed of 3 parts:
1. Libwally
2. Minsc
3. A middle layer that will expose functional API and calls the low-level libraries

### Libwally

[Libwally](https://github.com/ElementsProject/libwally-core) is a cross-platform library of bitcoin and elements wallet primitives.

It is written in C, and can be compiled with Python or Java wrapper.

See the [API](https://wally.readthedocs.io/) documentation for more information. 

### Minsc 

### Middle layer

## API call

## init

### Inputs

1. None

### Outputs

1. number `success`: if `0`, libwally is ready to go, any other value means something went wrong and none other calls can be made.

## newWallet

### Inputs

1. string `userPassword`: password chosen by the user. 

### Outputs

1. string `encryptedWallet`: a base58 encoded string that contains the following data encrypted with AES:
    * `xprv`: the private extended key.
    * `mnemonic` (or seed words): 12 (or 24) words that allow user to restore his wallet, including the private keys and blinding keys.
    * `masterBlindingKey`: the 64B key used to blind and unblind user's transactions.

### Description

`newWallet` is the first API call that must be made, since it generates all the cryptographic material we need for the subsequent steps.

It generates a seed (a `mnemonic` is basically a human-readable version of this), and from this seed an extended private key. 

From this key it is possible to derivate a virtually unlimited number of new key pairs. 

`xprv` is the most critical piece of information here, as anyone that get a hold of it can impersonate the user in any transaction, not only past, but also to come.

`xpub` is relatively less critical, having it would allow an attacker to derive all the pubkeys (hence the address) of the user. This could be a privacy issue, but since we blind everything and use a lot of multisig (which hides the participants pubkey as long as it is not spent), I don't think this is a concern here, that's why this is not returned encrypted. 

`master_blinding_key` should be protected, as compromising it wouldn't be as bad as the `xprv`, but would allow the attacker to unblind all the users' output.

It uses `userPassword` to encrypt the wallet data (AES CBC), and returns the cipher encoded in a base 58 string.

## new_address

### Inputs

1. string `xpub`: an extended public key (see `new_wallet`). Can be the user's, or someone else's.
2. string `hd_path`: must only contains numeric characters and `/` to separate them. List of indexes used for key derivation. 

### Outputs

1. string `address`: a base 58 bech32 address commiting to `pubkey`.
2. string `pubkey`: the public key found at `hd_path` for the given `xpub`.

## new_confidential_address

### Inputs

1. string `address`: an address generated by `new_address`
2. string `master_blinding_key`: return by `new_wallet`. 

### Outputs

1. string `confidential_address`: the base 58 encoded confidential address for the given `address` and `master_blinding_key`.
2. string `blinding_privkey`: the private key generated (32B) in hex format. Anyone having this information is also able to unblind all the outputs using this address.

## new_multisig_address

### Inputs

1. int `threshold`: the minimum number of signatures required out of the total number of pubkeys to produce a valid transaction.
2. int `total_signers`: the total number of signers. Must be more or equal to `threshold`
3. string `pubkeys`: all the pubkeys used in the multisig, space separated.
4. string `hd_paths`: all the derivation paths, space separated, there must be as many paths than pubeys.

### Outputs

1. string `redeem_script`: a hex encoded byte string of the resulting bitcoin script.
2. string `address`: a bech32 address commiting to the `redeem_script`.

**Note**: those multisig adresses are unblinded, and must be blinded with `new_confidential` address. But since the address is shared amongst _n_ participants, they all need the blinding keys. Any user in the multisig could use his own master blinding key to create a confidential transaction, but should then share the key with all the other participants.

## create_tx

### Inputs

1. string `prev_tx`: hex encoded transaction containing the UTXO we're spending.
2. string `asset`: hex encoded asset ID of the asset provided on enrollment.
3. string `address_1`: address of the first output.
4. (optional)string `address_2`: address for the second output. 
5. (optional)string `contract_hash`: an optional 32B piece of information (usually, a hash) that can be committed inside the asset issuance.

### Outputs

1. string `tx`: hex encoded new transaction that spends `prev_tx`

## sign_tx

### Inputs

1. string `tx`: hex encoded transaction to sign
2. string `hd_path`: must only contains numeric characters and `/` to separate them. List of indexes used for key derivation. 
3. string `value`: amount of the UTXO we're speding. If the previous transaction was blinded, it is the field `valuecommitment` in the output of `decoderawtransaction` elements rpc call. If it's not, pass the clear amount (e.g. "1.00012").

### Outputs

1. string `signed_tx`: hex encoded signed transaction
